/**
 * TDD Phase 3.3.1.1: Ï°∞ÏßÅ API ÌÖåÏä§Ìä∏
 * üü¢ GREEN: ÌÖåÏä§Ìä∏ ÌÜµÍ≥ºÎ•º ÏúÑÌïú ÏàòÏ†ï
 */

import { jest } from '@jest/globals';
import { organizationApi } from '@/api/organization.api';
import { OrganizationType, OrganizationStatus, OrganizationListParams } from '@/types/organization.types';

// Mock fetch
global.fetch = jest.fn() as jest.Mock;

describe('Organization API - TDD Green Phase', () => {
  const mockFetch = global.fetch as jest.Mock;

  beforeEach(() => {
    mockFetch.mockClear();
  });

  describe('üü¢ getOrganizationList API ÌÖåÏä§Ìä∏', () => {
    const mockResponse = {
      organizations: [
        {
          id: 'org-1',
          name: 'ÌÖåÏä§Ìä∏ ÌöåÏÇ¨ A',
          type: 'CORP',
          businessRegistrationNumber: '123-45-67890',
          status: 'ACTIVE',
          employeeCount: 25,
          createdAt: '2024-01-15T00:00:00Z',
          updatedAt: '2024-01-15T00:00:00Z'
        }
      ],
      total: 1,
      page: 1,
      pageSize: 20,
      totalPages: 1,
      hasNextPage: false,
      hasPreviousPage: false
    };

    test('Í∏∞Î≥∏ ÌååÎùºÎØ∏ÌÑ∞Î°ú Ï°∞ÏßÅ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï† Ïàò ÏûàÏñ¥Ïïº Ìï®', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      const result = await organizationApi.getOrganizationList();

      expect(mockFetch).toHaveBeenCalledWith('/api/organizations', {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer mock-token'
        }
      });

      expect(result).toEqual({
        ...mockResponse,
        organizations: [{
          ...mockResponse.organizations[0],
          createdAt: new Date('2024-01-15T00:00:00Z'),
          updatedAt: new Date('2024-01-15T00:00:00Z')
        }]
      });
    });

    test('Í≤ÄÏÉâ ÌïÑÌÑ∞Í∞Ä ÏøºÎ¶¨ Ïä§Ìä∏ÎßÅÏóê Ìè¨Ìï®ÎêòÏñ¥Ïïº Ìï®', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      const params: OrganizationListParams = {
        filters: {
          search: 'ÌÖåÏä§Ìä∏',
          status: [OrganizationStatus.ACTIVE],
          type: [OrganizationType.CORP]
        }
      };

      await organizationApi.getOrganizationList(params);

      const callUrl = mockFetch.mock.calls[0][0] as string;
      expect(callUrl).toContain('search=%ED%85%8C%EC%8A%A4%ED%8A%B8'); // URL encoded 'ÌÖåÏä§Ìä∏'
      expect(callUrl).toContain('status=ACTIVE');
      expect(callUrl).toContain('type=CORP');
    });

    test('Ï†ïÎ†¨ ÌååÎùºÎØ∏ÌÑ∞Í∞Ä ÏøºÎ¶¨ Ïä§Ìä∏ÎßÅÏóê Ìè¨Ìï®ÎêòÏñ¥Ïïº Ìï®', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      const params: OrganizationListParams = {
        sort: {
          field: 'name',
          direction: 'asc'
        }
      };

      await organizationApi.getOrganizationList(params);

      const callUrl = mockFetch.mock.calls[0][0] as string;
      expect(callUrl).toContain('sortField=name');
      expect(callUrl).toContain('sortDirection=asc');
    });

    test('ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò ÌååÎùºÎØ∏ÌÑ∞Í∞Ä ÏøºÎ¶¨ Ïä§Ìä∏ÎßÅÏóê Ìè¨Ìï®ÎêòÏñ¥Ïïº Ìï®', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      const params: OrganizationListParams = {
        page: 2,
        pageSize: 50
      };

      await organizationApi.getOrganizationList(params);

      const callUrl = mockFetch.mock.calls[0][0] as string;
      expect(callUrl).toContain('page=2');
      expect(callUrl).toContain('pageSize=50');
    });

    test('ÏßÅÏõêÏàò Î≤îÏúÑ ÌïÑÌÑ∞Í∞Ä ÏøºÎ¶¨ Ïä§Ìä∏ÎßÅÏóê Ìè¨Ìï®ÎêòÏñ¥Ïïº Ìï®', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      const params: OrganizationListParams = {
        filters: {
          employeeCountRange: {
            min: 10,
            max: 100
          }
        }
      };

      await organizationApi.getOrganizationList(params);

      const callUrl = mockFetch.mock.calls[0][0] as string;
      expect(callUrl).toContain('employeeMin=10');
      expect(callUrl).toContain('employeeMax=100');
    });

    test('ÎÇ†Ïßú Î≤îÏúÑ ÌïÑÌÑ∞Í∞Ä ÏøºÎ¶¨ Ïä§Ìä∏ÎßÅÏóê Ìè¨Ìï®ÎêòÏñ¥Ïïº Ìï®', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse
      });

      const params: OrganizationListParams = {
        filters: {
          dateRange: {
            startDate: new Date('2024-01-01'),
            endDate: new Date('2024-12-31')
          }
        }
      };

      await organizationApi.getOrganizationList(params);

      const callUrl = mockFetch.mock.calls[0][0] as string;
      expect(callUrl).toContain('startDate=2024-01-01');
      expect(callUrl).toContain('endDate=2024-12-31');
    });

    test('API Ïò§Î•òÏãú Ï†ÅÏ†àÌïú ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥Ïïº Ìï®', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 403,
        statusText: 'Forbidden',
        json: async () => ({ error: 'Insufficient permissions' })
      });

      await expect(organizationApi.getOrganizationList()).rejects.toThrow('Insufficient permissions');
    });

    test('ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•òÏãú Ï†ÅÏ†àÌïú ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥Ïïº Ìï®', async () => {
      mockFetch.mockRejectedValueOnce(new Error('Network error'));

      await expect(organizationApi.getOrganizationList()).rejects.toThrow('Network error');
    });
  });

  describe('üü¢ getOrganizationStats API ÌÖåÏä§Ìä∏', () => {
    const mockStatsResponse = {
      totalOrganizations: 150,
      activeOrganizations: 120,
      inactiveOrganizations: 25,
      pendingOrganizations: 5,
      totalEmployees: 2500,
      organizationsByType: {
        CORP: 80,
        PERSONAL: 60,
        FRANCHISE: 10
      },
      recentCreations: 12
    };

    test('Ï°∞ÏßÅ ÌÜµÍ≥ÑÎ•º Ï°∞ÌöåÌï† Ïàò ÏûàÏñ¥Ïïº Ìï®', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => mockStatsResponse
      });

      const result = await organizationApi.getOrganizationStats();

      expect(mockFetch).toHaveBeenCalledWith('/api/organizations/stats', {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer mock-token'
        }
      });

      expect(result).toEqual(mockStatsResponse);
    });

    test('ÌÜµÍ≥Ñ API Ïò§Î•òÏãú Ï†ÅÏ†àÌïú ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥Ïïº Ìï®', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        json: async () => ({ error: 'Internal server error' })
      });

      await expect(organizationApi.getOrganizationStats()).rejects.toThrow('Internal server error');
    });
  });

  describe('üü¢ Ïù∏Ï¶ù ÌÜ†ÌÅ∞ ÌÖåÏä§Ìä∏', () => {
    test('Ïù∏Ï¶ù ÌÜ†ÌÅ∞Ïù¥ Ìó§ÎçîÏóê Ìè¨Ìï®ÎêòÏñ¥Ïïº Ìï®', async () => {
      // localStorage mockÏùÑ ÏÑ§Ï†ïÌïòÏó¨ Ïã§Ï†ú ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù ÌÖåÏä§Ìä∏
      const originalWindow = global.window;
      global.window = {
        localStorage: {
          getItem: jest.fn(() => 'real-jwt-token')
        }
      } as any;

      // NODE_ENVÎ•º ÌÖåÏä§Ìä∏Í∞Ä ÏïÑÎãå Í≤ÉÏúºÎ°ú ÏÑ§Ï†ï
      const originalEnv = process.env.NODE_ENV;
      process.env.NODE_ENV = 'development';

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ organizations: [] })
      });

      await organizationApi.getOrganizationList();

      expect(mockFetch).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          headers: expect.objectContaining({
            'Authorization': 'Bearer real-jwt-token'
          })
        })
      );

      // ÏõêÎûò Í∞í Î≥µÏõê
      global.window = originalWindow;
      process.env.NODE_ENV = originalEnv;
    });

    test('Ïù∏Ï¶ù ÌÜ†ÌÅ∞Ïù¥ ÏóÜÏùÑ Îïå ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥Ïïº Ìï®', async () => {
      // localStorage mockÏùÑ Îπà ÏÉÅÌÉúÎ°ú ÏÑ§Ï†ï
      const originalWindow = global.window;
      global.window = {
        localStorage: {
          getItem: jest.fn(() => null)
        },
        sessionStorage: {
          getItem: jest.fn(() => null)
        }
      } as any;

      // NODE_ENVÎ•º ÌÖåÏä§Ìä∏Í∞Ä ÏïÑÎãå Í≤ÉÏúºÎ°ú ÏÑ§Ï†ï
      const originalEnv = process.env.NODE_ENV;
      process.env.NODE_ENV = 'development';

      await expect(organizationApi.getOrganizationList()).rejects.toThrow('Authentication token not found');

      // ÏõêÎûò Í∞í Î≥µÏõê
      global.window = originalWindow;
      process.env.NODE_ENV = originalEnv;
    });
  });

  describe('üü¢ ÏøºÎ¶¨ Ïä§Ìä∏ÎßÅ ÏÉùÏÑ± ÌÖåÏä§Ìä∏', () => {
    test('Î≥µÌï© ÌïÑÌÑ∞ Ï°∞Í±¥Ïù¥ Ïò¨Î∞îÎ•¥Í≤å ÏøºÎ¶¨ Ïä§Ìä∏ÎßÅÏúºÎ°ú Î≥ÄÌôòÎêòÏñ¥Ïïº Ìï®', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ organizations: [] })
      });

      const params: OrganizationListParams = {
        page: 2,
        pageSize: 25,
        filters: {
          search: 'ÏÇºÏÑ±Ï†ÑÏûê',
          status: [OrganizationStatus.ACTIVE, OrganizationStatus.PENDING],
          type: [OrganizationType.CORP],
          employeeCountRange: { min: 50, max: 200 },
          dateRange: {
            startDate: new Date('2024-01-01'),
            endDate: new Date('2024-06-30')
          }
        },
        sort: {
          field: 'employeeCount',
          direction: 'desc'
        }
      };

      await organizationApi.getOrganizationList(params);

      const callUrl = mockFetch.mock.calls[0][0] as string;
      
      expect(callUrl).toContain('page=2');
      expect(callUrl).toContain('pageSize=25');
      expect(callUrl).toContain('search=%EC%82%BC%EC%84%B1%EC%A0%84%EC%9E%90'); // URL encoded
      expect(callUrl).toContain('status=ACTIVE');
      expect(callUrl).toContain('status=PENDING');
      expect(callUrl).toContain('type=CORP');
      expect(callUrl).toContain('employeeMin=50');
      expect(callUrl).toContain('employeeMax=200');
      expect(callUrl).toContain('startDate=2024-01-01');
      expect(callUrl).toContain('endDate=2024-06-30');
      expect(callUrl).toContain('sortField=employeeCount');
      expect(callUrl).toContain('sortDirection=desc');
    });

    test('Îπà ÌïÑÌÑ∞Îäî ÏøºÎ¶¨ Ïä§Ìä∏ÎßÅÏóê Ìè¨Ìï®ÎêòÏßÄ ÏïäÏïÑÏïº Ìï®', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ organizations: [] })
      });

      const params: OrganizationListParams = {
        filters: {
          search: '',
          status: [],
          type: []
        }
      };

      await organizationApi.getOrganizationList(params);

      const callUrl = mockFetch.mock.calls[0][0] as string;
      
      expect(callUrl).not.toContain('search=');
      expect(callUrl).not.toContain('status=');
      expect(callUrl).not.toContain('type=');
    });
  });
});